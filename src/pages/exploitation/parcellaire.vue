<route lang="yaml">
meta:
  requiresAuth: true
  requiresGeodata: true
  seo:
    title: Gestion de mon parcellaire AB
</route>

<template>
  <section class="fr-container fr-py-2w">
    <AbDetails class="fr-my-3w" :user="currentUser" />

    <div class="fr-grid-row fr-grid-row--gutters">
      <div class="fr-col-6">
        <table class="fr-table fr-table--bordered fr-pt-0" v-for="({ features, label, surface, accentColor, key }) in featureGroups" :key="key" @mouseout="hoveredFeatureId = null">
          <caption v-if="label">
            <span class="color-badge" :style="{ '--accent-color': accentColor }" />
            {{ label }}
            ({{ surface }}&nbsp;ha)
          </caption>

          <thead>
            <tr>
              <th scope="col"></th>
              <th scope="col">Taille</th>
              <th scope="col">Parcelle</th>
            </tr>
          </thead>

          <tbody>
            <tr v-for="({ properties: props, id }) in features" :id="'p' + id" @mouseover="hoveredFeatureId = id" :key="props.NUMERO_I + props.NUMERO_P" :aria-current="id === selectedFeatureId" :class="{hovered: id === hoveredFeatureId, selected: selectedFeatureIds.has(id)}">
              <th scope="row" class="rowIdCell">
                <!-- <input type="checkbox" :checked="selectedFeatureIds.has(id)" @click.stop="toggleFeatureSelection({ id })" /> -->
              </th>
              <td class="numeric">{{ numericFormat(props.SURF) }}&nbsp;ha</td>
              <td>
                <span class="culture-type">{{ libelléFromCode(props.TYPE) }}</span>
              </td>
            </tr>
          </tbody>
        </table>

        <ul class="fr-btns-group fr-btns-group--inline">
          <li v-if="mode === 'read'">
              <button class="fr-btn" @click="handleSubmitParcellesChange" :disabled="isSending">
                Valider ce parcellaire
              </button>
          </li>
          <li v-if="mode === 'read'">
              <button class="fr-btn fr-btn--secondary" @click="mode = MODE_WRITE">
                Modifier les cultures en place
              </button>
          </li>
          <li v-if="mode === 'write'">
              <button class="fr-btn" @click="mode = MODE_READ">
                Enregistrer ces cultures
              </button>
          </li>
          <li v-if="mode === 'write'">
              <button class="fr-btn fr-btn--secondary" @click="parcellaire = copyRef(initialParcellaire); mode = MODE_READ">
                Annuler ces modification
              </button>
          </li>
        </ul>

        <p>
          <a href="#top" class="fr-icon--sm fr-icon-arrow-up-fill">
            retour en haut de page
          </a>
        </p>
      </div>

      <div class="fr-col-6">
        <MapContainer :style="baseVectorStyles" :options="{ interactive: false }" class="map" @load="loadSourceAndLayers" :bounds="mapBounds">
          <GeojsonLayer :data="parcellaire" name="parcellaire-operateur" />
        </MapContainer>
      </div>
    </div>


  </section>
</template>

<script setup>
import { computed, ref, toRaw, toRefs, shallowRef, watch, nextTick } from 'vue'
import groupBy from 'array.prototype.groupby'
import bbox from '@turf/bbox'
import area from '@turf/area'
import centroid from '@turf/centroid'
import { featureCollection } from '@turf/helpers'
import { libelléFromCode } from '@/referentiels/pac.js'
import { conversionLevels } from '@/referentiels/ab.js'
import { submitParcellesChanges } from '@/cartobio-api.js'

import store from '@/store.js'
import MapContainer from '@/components/Map/MapContainer.vue'
import GeojsonLayer from '@/components/Map/GeojsonLayer.vue'
import AbDetails from '@/components/Certification/AbDetails.vue'

const copyRef = (refValue) => structuredClone(toRaw(refValue))

const { currentUser, parcellaire } = toRefs(store.state)
const initialParcellaire = copyRef(store.state.parcellaire)
const hoveredFeatureId = ref(null)
const baseVectorStyles = 'https://openmaptiles.geo.data.gouv.fr/styles/osm-bright/style.json'

// user single selected/feature focus
const selectedFeatureId = ref(null)
const selectedFeature = computed(() => selectedFeatureId.value ? getFeatureById(selectedFeatureId.value) : null)

// user selected/checked features
const selectedFeatureIds = ref(new Set())
const selectedFeatures = computed(() => Array.from(selectedFeatureIds.value).map(getFeatureById))

const map = shallowRef(null)
const mapBounds = computed(() => bbox(parcellaire.value))
const popupLngLat = ref([0, 0])

const inHa = (value) => numericFormat(parseFloat((value / 10000)))
const numericFormat = (value) => value.toLocaleString('fr-FR', { maximumFractionDigits: 2, minimumFractionDigits: 2 })

const groupingChoices = {
  '': { label: '…' },
  'COMMUNE': {
    label: 'commune',
    datapoint: (d) => d.properties.COMMUNE,
    groupLabelFn: (d) => d.properties.COMMUNE
  },
  'CULTURE': {
    label: 'culture',
    datapoint: (d) => d.properties.TYPE,
    groupLabelFn: (d) => libelléFromCode(d.properties.TYPE)
  },
  'NIVEAU_CONVERSION': {
    label: 'niveau de conversion',
    datapoint: (d) => d.properties.conversion_niveau || '',
    groupLabelFn: (d, groupingKey) => conversionLevels.find(({ value }) => value === groupingKey)?.label
  },
  'ANNEE_ENGAGEMENT': {
    label: 'année d\'engagement',
    datapoint: (d) => d.properties.engagement_date ? new Date(d.properties.engagement_date).getFullYear() : '',
    groupLabelFn: (d, groupingKey) => groupingKey || 'Année d\'engagement inconnue'
  },
}

const colorPalette = [
  "#000091",
  "#ff73fa",
  "#76b100",
  "#ba00ae",
  "#01c672",
  "#0045b4",
  "#e1cc00",
  "#7c2d82",
  "#feff7c",
  "#ff8dee",
  "#408b00",
  "#b61300",
  "#ac9200"
]

const MODE_READ = 'read'
const MODE_WRITE = 'write'

const isSending = ref(false)
const mode = ref(MODE_READ)
const userGroupingChoice = ref('')
const handleUserGroupingChoice = ($event) => userGroupingChoice.value = $event.target.value

async function handleSubmitParcellesChange () {
  isSending.value = true

  try {
    await submitParcellesChanges(parcellaire.value)
    initialParcellaire.value = copyRef(parcellaire)
  }
  catch (error) {
    console.error(error)
  }
  finally {
    isSending.value = false
  }
}

function addFeaturesToSelection (features) {
  const newIds = new Set()
  features.forEach(({ id }) => newIds.add(id))
  selectedFeatureIds.value = new Set([...selectedFeatureIds.value, ...newIds])
}

function removeFeaturesFromSelection (features) {
  const remainingIds = new Set([...selectedFeatureIds.value])
  features.forEach(({ id }) => remainingIds.delete(id))
  selectedFeatureIds.value = remainingIds
}

function toggleFeatureSelection (feature) {
  selectedFeatureIds.value.has(feature.id)
    ? removeFeaturesFromSelection([feature])
    : addFeaturesToSelection([feature])
}

const featureGroups = computed(() => {
  if (userGroupingChoice.value === '') {
    return [{
      label: '',
      key: 'none',
      accentColor: colorPalette[0],
      features: parcellaire.value.features,
      surface: inHa(area(featureCollection(parcellaire.value.features)))
    }]
  }

  const groups = groupBy(parcellaire.value.features, (feature) => {
    return groupingChoices[userGroupingChoice.value].datapoint(feature)
  })

  return Object.entries(groups).map(([key, features], i) => ({
    label: groupingChoices[userGroupingChoice.value].groupLabelFn(features[0], key),
    key,
    accentColor: colorPalette[i%12],
    features,
    surface: inHa(area(featureCollection(features)).toFixed(2)),
  })).sort((a, b) => b.surface - a.surface)
})

const featureGroupsStyles = computed(() => {
  return featureGroups.value.flatMap(({ features, accentColor }) => ([
    ['in', ['get', 'id'], ['literal', features.map(({ id }) => id)]],
    accentColor
  ]))
})

const hasChanged = computed(() => JSON.stringify(parcellaire.value) !== initialParcellaire.value)
const canSave = computed(() => isSending.value === false && hasChanged.value === true)

const handleMassGroupEditSubmit = (formState) => {
  parcellaire.value.features
    .filter(({ id }) => selectedFeatureIds.value.has(id))
    .forEach(({ properties }) => {
      Object.entries(formState)
        .filter(([key, value]) => value !== undefined)
        .forEach(([key, value]) => properties[key] = value)
    })

  clearSelectedFeatures()
}

const handleSingleFeatureEditSubmit = (formState) => {
  const feature = selectedFeature.value

  Object.entries(formState)
      .filter(([key, value]) => value !== undefined)
      .forEach(([key, value]) => feature.properties[key] = value)

  selectedFeatureId.value = null
}

function clearSelectedFeatures () {
  selectedFeatureIds.value = new Set()
}

const getFeatureById = (id) => {
  return parcellaire.value.features.find(feature => feature.id === id)
}

const handleFeatureSelectionFromTable = (id) => {
  if (selectedFeatureId.value === id) {
    selectedFeatureId.value = null
    return
  }

  selectedFeatureId.value = id
  zoomInto(getFeatureById(id), { maxZoom: 15 })
}

function zoomInto (featureOrFeatureCollection, { maxZoom }) {
  const bounds = bbox(featureOrFeatureCollection)
  const { center, zoom, bearing } = map.value.cameraForBounds(bounds, { padding: 50, maxZoom }) ?? {}
  if (center && zoom) {
    map.value.flyTo({ center, zoom, bearing })
  }
}

function dateDDMMYYY (date) {
  return new Date(date).toLocaleDateString('fr-FR', {
    dateStyle: 'short',
    timeZone: 'Europe/Paris'
  })
}

function loadSourceAndLayers (maplibreMap) {
  map.value = maplibreMap

  // zoomInto(parcellaire.value, { maxZoom: 13 })

  watch(hoveredFeatureId, (id, previousId) => {
    if (id) {
      maplibreMap.setFeatureState({ source: 'parcellaire-operateur', id }, { hover: true })
    }

    if (previousId){
      maplibreMap.setFeatureState({ source: 'parcellaire-operateur', id: previousId }, { hover: false })
    }
  })

  watch(() => selectedFeatureIds, (currentIds) => {
    currentIds.value.forEach(id => {
      maplibreMap.setFeatureState({ source: 'parcellaire-operateur', id }, { selected: true })
    })

    parcellaire.value.features.forEach(({ id }) => {
      const { selected } = maplibreMap.getFeatureState({ id, source: 'parcellaire-operateur' })
      if (selected && !currentIds.value.has(id)) {
        maplibreMap.setFeatureState({ source: 'parcellaire-operateur', id }, { selected: false })
      }
    })
  }, { deep: true })

  watch(selectedFeatureId, (id, previousId) => {
    if (id) {
      maplibreMap.setFeatureState({ source: 'parcellaire-operateur', id }, { selected: true })

      popupLngLat.value = centroid(selectedFeature.value).geometry.coordinates
    }

    if (previousId){
      map.value.setFeatureState({ source: 'parcellaire-operateur', id: previousId }, { selected: false })
    }
  })

  maplibreMap.on('mousemove', 'parcellaire-operateur-geometry', ({ features }) => {
    if (features.length) {
      hoveredFeatureId.value = features[0].id
      map.value.getCanvas().style.cursor = "pointer"
    }
  })

  maplibreMap.on('mouseleave', 'parcellaire-operateur-geometry', () => {
    if (hoveredFeatureId.value) {
      hoveredFeatureId.value = null
      maplibreMap.getCanvas().style.cursor = ""
    }
  })

  maplibreMap.on('click', 'parcellaire-operateur-geometry', ({ lngLat }) => {
    const point = maplibreMap.project(lngLat)
    const features = maplibreMap.queryRenderedFeatures(point, { layers: ['parcellaire-operateur-geometry'] })

    if (features.length) {
      selectedFeatureId.value = features[0].id
      nextTick(() => document.querySelector('tr[aria-current="true"]')?.scrollIntoView({ behavior: 'smooth', block: 'center' }))
    }
  })
}
</script>

<style scoped>
.fr-table {
  border-collapse: collapse;
  width: 100%;
}

  table .color-badge {
    background-color: var(--accent-color);
    display: inline-block;
    height: 14px;
    width: 14px;
  }

  table tr.hovered {
    background-color: #00ffff50;
    cursor: pointer;
  }


.rowIdCell small {
  font-weight: normal;
  margin-left: .5rem;
}

.numeric:is(td, th) {
  font-variant-numeric: tabular-nums;
  text-align: right;
}

.culture-type,
.culture-group {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  display: block;
  max-width: 350px;
}

.map {
  background: #ccc;
  height: min(100vh, 600px);
  position: sticky;
  top: 0;
  width: 100%;
}

</style>
