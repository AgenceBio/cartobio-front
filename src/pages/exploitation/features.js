import { toRaw } from 'vue'
import groupBy from 'array.prototype.groupby'
import { featureCollection, feature } from '@turf/helpers'
import area from '@turf/area'
import { libelléFromCode } from '@/referentiels/pac.js'
import { conversionLevels } from '@/referentiels/ab.js'

const colorPalette = [
  "#ff73fa",
  "#76b100",
  "#ba00ae",
  "#01c672",
  "#0045b4",
  "#e1cc00",
  "#7c2d82",
  "#feff7c",
  "#ff8dee",
  "#408b00",
  "#b61300",
  "#ac9200"
]

export const groupingChoices = {
  'COMMUNE': {
    label: 'commune',
    datapoint: (d) => d.properties.COMMUNE,
    groupLabelFn: (d) => d.properties.COMMUNE
  },
  'CULTURE': {
    label: 'culture',
    datapoint: (d) => d.properties.TYPE,
    groupLabelFn: (d) => libelléFromCode(d.properties.TYPE)
  },
  'NIVEAU_CONVERSION': {
    label: 'niveau de conversion',
    datapoint: (d) => d.properties.conversion_niveau || '',
    groupLabelFn: (d, groupingKey) => conversionLevels.find(({ value }) => value === groupingKey)?.label || 'Niveau de conversion inconnu'
  },
  'ANNEE_ENGAGEMENT': {
    label: 'année d\'engagement',
    datapoint: (d) => d.properties.engagement_date ? new Date(d.properties.engagement_date).getFullYear() : '',
    groupLabelFn: (d, groupingKey) => groupingKey || 'Année d\'engagement inconnue'
  },
}

export function getFeatureGroups (collection, pivot = 'CULTURE') {
  if (pivot === '') {
    return [{
      label: '',
      key: 'none',
      accentColor: colorPalette[0],
      features: collection.features,
      surface: inHa(area(featureCollection(collection.features)))
    }]
  }

  const groups = groupBy(collection.features, (feature) => {
    return groupingChoices[pivot].datapoint(feature)
  })

  return Object.entries(groups).map(([key, features], i) => ({
    label: groupingChoices[pivot].groupLabelFn(features[0], key),
    key,
    accentColor: colorPalette[i%12],
    features,
    surface: area(featureCollection(features)),
  })).sort((a, b) => b.surface - a.surface)
}

export function getFeatureGroupsStyles (groups) {
  return groups.flatMap(({ features, accentColor }) => ([
    ['in', ['get', 'id'], ['literal', features.map(({ id }) => id)]],
    accentColor
  ]))
}

export function inHa (value) {
  return parseFloat((value / 10000))
    .toLocaleString('fr-FR', {
      maximumFractionDigits: 2,
      minimumFractionDigits: 2
    })
}

export function surface (geometryOrFeature) {
  return ['FeatureCollection', 'Feature'].includes(geometryOrFeature.type)
    // we have a full feature
    ? area(geometryOrFeature)
    // we only have a geometry
    : area(feature(geometryOrFeature))
}
