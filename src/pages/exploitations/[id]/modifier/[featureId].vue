<route lang="yaml">
meta:
  requiredPermissions: ['canChangeGeometry']
  seo:
    title: Modifier le tracé de la parcelle
</route>

<template>
  <section class="fr-container fr-py-9v">
    <p>
      <router-link :to="permissions.isOc ? `/certification/exploitations/${props.id}` : `/exploitations/${props.id}`" class="fr-btn fr-btn--tertiary-no-outline fr-btn--icon-left fr-icon-arrow-left-line">
        Retour au parcellaire
      </router-link>
    </p>

    <ParcellaireState :state="recordStore.record.certification_state" :date="recordStore.record.created_at" />
    <h2 class="fr-h4 fr-my-3v">{{ recordStore.record.operator.nom }}</h2>
    <h3 class="fr-h5 fr-my-3v">Modifier le contour de «&nbsp;{{ modifiedFeature && featureName(modifiedFeature) }}&nbsp;»</h3>

    <div class="fr-grid-row fr-grid-row--gutters">
      <div class="fr-col-9">
        <MapContainer v-if="recordStore.isSetup" :options="{ interactive: true }" class="map" :bounds="mapBounds" ref="map" >
          <GeojsonLayer :style="baseStyle" name="base" />
          <GeojsonLayer :data="otherCollection" name="parcellaire-operateur" />
        </MapContainer>
      </div>
      <div class="fr-col-3">
        <div class="controls">
          <p><b>Mode d'emploi</b></p>
          <ol>
            <li><b>Modifier&nbsp;:</b> Cliquez sur votre parcelle et déplacez les points.</li>
            <li><b>Enregistrer&nbsp;:</b> Cliquez sur “Enregistrer le tracé”.</li>
          </ol>
          <button
              class="fr-btn fr-btn--tertiary-no-outline fr-btn--icon-left fr-icon-arrow-go-back-fill fr-mb-4w"
              @click="reset"
              :disabled="feature === null"
          >
            Réinitialiser le tracé</button>
          <div v-if="error" class="fr-alert fr-alert--error">
            <p>{{ error }}</p>
          </div>
          <button
              class="fr-btn fr-btn--primary fr-btn--icon-left fr-icon-save-fill"
              :disabled="error !== ''"
              @click="showConfirmModal = true"
          >
            Enregistrer le tracé
          </button>
        </div>
      </div>
    </div>
  </section>

  <Teleport to="body">
    <Modal v-if="showConfirmModal" v-model="showConfirmModal" icon="fr-icon-geometry">
      <template #title>Modifier le contour</template>
      <template #default>
        <p>
          Vous êtes sur le point de modifier le contour
          de la parcelle « {{ featureName(modifiedFeature) }} » votre tracé
        </p>
        <p>Sa superficie est désormais de {{ inHa(surface(modifiedFeature)) }} ha.</p>
      </template>
      <template #footer>
        <ul class="fr-btns-group fr-btns-group--inline fr-btns-group--left fr-btns-group--icon-left">
          <li><button class="fr-btn fr-btn--primary" @click="saveFeature">Enregistrer</button></li>
          <li><button class="fr-btn fr-btn--secondary" @click="showConfirmModal = false">Annuler</button></li>
        </ul>
      </template>
    </Modal>
  </Teleport>
</template>

<script setup>

import baseStyle from "@/map-styles/base.json"
import ParcellaireState from "@/components/Certification/State.vue"
import MapContainer from "@/components/Map/MapContainer.vue"
import GeojsonLayer from "@/components/Map/GeojsonLayer.vue"
import { useFeaturesStore, useMessages, usePermissions, useRecordStore } from "@/stores/index.js"
import { computed, onMounted, ref, watch } from "vue"
import bbox from "@turf/bbox"
import { TerraDraw, TerraDrawMapLibreGLAdapter, TerraDrawPolygonMode, TerraDrawSelectMode } from "terra-draw"
import intersect from "@turf/intersect"
import { featureName, inHa, surface } from "@/components/Features/index.js"
import { feature, featureCollection } from "@turf/helpers"
import { updateSingleFeature } from "@/cartobio-api.js"
import { statsPush } from "@/stats.js"
import { useRouter } from "vue-router"
import Modal from "@/components/Modal.vue"

const props = defineProps({
  id: {
    type: String,
    required: true
  },
  featureId: {
    type: String,
    required: true
  },
})

const recordStore = useRecordStore()
const featureStore = useFeaturesStore()
const permissions = usePermissions()
const messages = useMessages()
const router = useRouter()

const otherCollection = computed(() => featureCollection(
    featureStore.collection.features.filter(f => f.id !== Number(props.featureId)))
)
const modifiedFeature = ref(null)

const mapBounds = computed(() => {
  if (recordStore.isSetup) {
    return bbox(featureStore.getFeatureById(Number(props.featureId)))
  }

  return []
})

const map = ref(null) // MapContainer instance
let draw // TerraDraw instance
const error = ref('')
const showConfirmModal = ref(false)


const COORDINATE_PRECISION = 16
onMounted(() => {
  draw = new TerraDraw({
    adapter: new TerraDrawMapLibreGLAdapter({ map: map.value.map, coordinatePrecision: COORDINATE_PRECISION }),
    modes: [
      new TerraDrawPolygonMode({
        coordinatePrecision: COORDINATE_PRECISION,
        allowSelfIntersections: false,
        styles: {
          fillColor: "#000091",
          fillOpacity: 0.1,
          outlineColor: "#000091",
          outlineWidth: 2,
          closingPointColor: "#000091",
        }
      }),
      new TerraDrawSelectMode({
        coordinatePrecision: COORDINATE_PRECISION,
        styles: {
          selectedPolygonColor: "#000091",
          selectedPolygonFillOpacity: 0.1,
          selectedPolygonOutlineColor: "#000091",
          selectedPolygonOutlineWidth: 2,
          selectionPointColor: "#000091",
          midPointColor: "#000091",
        },
        flags: {
          polygon: {
            feature: {
              draggable: true,
              rotateable: true,
              scaleable: true,
              selfIntersectable: false,
              coordinates: {
                midpoints: true,
                draggable: true,
                deletable: true
              }
            }
          }
        }
      })
    ],
  })
  draw.start()
  loadFeature()
  draw.on("finish", () => { modifiedFeature.value.geometry = draw.getSnapshot()[0].geometry })
})

function loadFeature () {
  draw.setMode("polygon")
  const terraDrawFeature = feature(featureStore.getFeatureById(Number(props.featureId)).geometry)
  // Round coordinates to COORDINATE_PRECISIONS - 1 decimals
  terraDrawFeature.geometry.coordinates = terraDrawFeature.geometry.coordinates.map(
      coord => coord.map(c => c.map(n => Number(n.toFixed(COORDINATE_PRECISION - 1))))
  )
  terraDrawFeature.properties.mode = 'polygon'
  draw.addFeatures([terraDrawFeature])

  // Clone feature to avoid modifying the featureStore
  modifiedFeature.value = JSON.parse(JSON.stringify(featureStore.getFeatureById(Number(props.featureId))))
  draw.setMode("select")
}

function reset () {
  draw.clear()
  loadFeature()
}

watch(modifiedFeature, () => {
  if (otherCollection.value.features.some(f => intersect(f, modifiedFeature.value))) {
    error.value = 'Le contour que vous avez tracé recoupe l’une de vos parcelles existantes. Vous ne pouvez pas enregistrer ce contour.'
  } else {
    error.value = ''
  }
}, { deep: true })

async function saveFeature () {
  const record = await updateSingleFeature({ recordId: recordStore.record.record_id }, modifiedFeature.value)

  messages.addMessage({ type: 'success', text: 'Parcelle modifiée.' })
  recordStore.update(record)
  featureStore.setAll(record.parcelles.features)

  statsPush(['trackEvent', 'Parcelles', 'Modification (tracé)'])
  await router.push({
    query: { new: record.audit_history.at(-1).parcelleId },
    path: permissions.isOc ? `/certification/exploitations/${props.id}` : '/exploitation/parcellaire',
  })
}
</script>


<style>
.map {
  background: #ccc;
  height: min(100vh, 600px);
  position: sticky;
  top: 0;
  width: 100%;
}

.controls {
  position: relative;
  height: 100%;
}

.controls > *:nth-last-child(1) {
  position: absolute;
  bottom: 0;
  left: 0;
}

.fr-icon-geometry::before {
  mask-image: url(@/assets/icon-geometry.svg);
}
</style>
